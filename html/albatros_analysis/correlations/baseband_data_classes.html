<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>albatros_analysis.correlations.baseband_data_classes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>albatros_analysis.correlations.baseband_data_classes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy
import struct
import time
import numba as nb
import numpy as np
import os

if __name__ == &#34;__main__&#34;:
    import unpacking as unpk  # If loaded as top level script
else:
    from . import unpacking as unpk  # If loaded as a module

# keeping track of number of times specnum overflows in a given long-averaging run (e.g. several days)


@nb.njit(parallel=True)
def fill_arr(myarr, specnum, spec_per_packet):
    n = len(specnum)
    for i in nb.prange(n):
        for j in nb.prange(spec_per_packet):
            myarr[i * spec_per_packet + j] = specnum[i] + j


class Baseband:
    def __init__(self, file_name, readlen=-1, fixoverflow=True):
        with open(file_name, &#34;rb&#34;) as file_data:  # ,encoding=&#39;ascii&#39;)
            header_bytes = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            # setting all the header values
            self.header_bytes = 8 + header_bytes
            self.bytes_per_packet = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.length_channels = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.spectra_per_packet = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.bit_mode = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.have_trimble = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.channels = numpy.frombuffer(
                file_data.read(self.header_bytes - 88),
                &#34;&gt;%dQ&#34; % (int((header_bytes - 8 * 10) / 8)),
            )[
                0
            ]  # this line is sketchy but it should work as long as the header structure stays the same. I know there&#39;s 88 bytes of the header which is not the channel array, so the rest is the length of the channel array.
            self.gps_week = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.gps_timestamp = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.gps_latitude = struct.unpack(&#34;&gt;d&#34;, file_data.read(8))[0]
            self.gps_longitude = struct.unpack(&#34;&gt;d&#34;, file_data.read(8))[0]
            self.gps_elevation = struct.unpack(&#34;&gt;d&#34;, file_data.read(8))[0]
            self.specnum_overflow = 0

            if self.bit_mode == 1:
                self.channels = numpy.ravel(
                    numpy.column_stack((self.channels, self.channels + 1))
                )
                self.length_channels = int(self.length_channels * 2)
            if self.bit_mode == 4:
                self.channels = self.channels[::2]
                self.length_channels = int(self.length_channels / 2)

            self.num_packets = (
                os.fstat(file_data.fileno()).st_size - self.header_bytes
            ) // self.bytes_per_packet
            if readlen &gt;= 1:
                # interpreted as number of packets
                self.read_packets = int(readlen)
                print(&#34;Reading&#34;, self.read_packets, &#34;packets&#34;)
            elif readlen &gt; 0 and readlen &lt; 1:
                # fraction of file
                self.read_packets = int(self.num_packets * readlen)
                print(&#34;Reading&#34;, self.read_packets, &#34;packets&#34;)
            elif readlen == 0:
                print(&#34;Not reading any data&#34;)
                self.read_packets = 0
            else:
                self.read_packets = -1

            if self.read_packets != 0:
                file_data.seek(self.header_bytes)
                t1 = time.time()
                data = numpy.fromfile(
                    file_data,
                    count=self.read_packets,
                    dtype=[
                        (&#34;spec_num&#34;, &#34;&gt;I&#34;),
                        (&#34;spectra&#34;, &#34;%dB&#34; % (self.bytes_per_packet - 4)),
                    ],
                )
                t2 = time.time()
                print(f&#34;took {t2-t1:5.3f} seconds to read raw data on &#34;, file_name)
                self.raw_data = numpy.array(data[&#34;spectra&#34;], dtype=&#34;uint8&#34;)
                self.spec_num = numpy.array(data[&#34;spec_num&#34;], dtype=&#34;int64&#34;)
                # check for specnum overflow in current file
                self.where_zero = np.where(np.diff(self.spec_num) &lt; 0)[0]
                if fixoverflow:
                    if len(self.where_zero) == 1:
                        self.spec_num[self.where_zero[0] + 1 :] += 2**32
                        self._set_specidx()
                    elif len(self.where_zero) &gt; 1:
                        raise ValueError(
                            &#34;Why are there two -ve diffs in specnum? Investigate this file&#34;
                        )
                self._set_specidx()

    def _set_specidx(self):
        self.spec_idx = numpy.zeros(
            self.spec_num.shape[0] * self.spectra_per_packet, dtype=&#34;int64&#34;
        )  # keep dtype int64 otherwise numpy binary search becomes slow
        fill_arr(self.spec_idx, self.spec_num, self.spectra_per_packet)
        specdiff = numpy.diff(self.spec_num)
        idx = numpy.where(specdiff != self.spectra_per_packet)[0]
        self.missing_loc = (
            self.spec_num[idx] + self.spectra_per_packet - self.spec_num[0]
        ).astype(&#34;int64&#34;)
        self.missing_num = (specdiff[idx] - self.spectra_per_packet).astype(&#34;int64&#34;)

    def print_header(self):
        print(
            &#34;Header Bytes = &#34;
            + str(self.header_bytes)
            + &#34;. Bytes per packet = &#34;
            + str(self.bytes_per_packet)
            + &#34;. Channel length = &#34;
            + str(self.length_channels)
            + &#34;. Spectra per packet: &#34;
            + str(self.spectra_per_packet)
            + &#34;. Bit mode: &#34;
            + str(self.bit_mode)
            + &#34;. Total packets = &#34;
            + str(self.num_packets)
            + &#34;. Read packets = &#34;
            + str(self.read_packets)
            + &#34;. Have trimble = &#34;
            + str(self.have_trimble)
            + &#34;. Channels: &#34;
            + str(self.channels)
            + &#34; GPS week = &#34;
            + str(self.gps_week)
            + &#34;. GPS timestamp = &#34;
            + str(self.gps_timestamp)
            + &#34;. GPS latitude = &#34;
            + str(self.gps_latitude)
            + &#34;. GPS longitude = &#34;
            + str(self.gps_longitude)
            + &#34;. GPS elevation = &#34;
            + str(self.gps_elevation)
            + &#34;.&#34;
        )

    def get_hist(self, mode=-1):
        # mode = 0 for pol0, 1 for pol1, -1 for both
        rowstart = 0
        rowend = len(self.spec_idx)
        return unpk.hist(
            self.raw_data, rowstart, rowend, self.length_channels, self.bit_mode, mode
        )


def get_header(file_name, verbose=True):
    obj = Baseband(file_name, readlen=0)
    if verbose:
        obj.print_header()
    return obj.__dict__


class BasebandFloat(Baseband):
    def __init__(
        self, file_name, readlen=-1, fixoverflow=True, chanstart=0, chanend=None
    ):
        super().__init__(file_name, readlen)
        self.chanstart = chanstart
        if chanend == None:
            self.chanend = self.length_channels
        else:
            self.chanend = chanend

        if self.bit_mode == 4:
            self.pol0, self.pol1 = unpk.unpack_4bit(
                self.raw_data,
                self.length_channels,
                0,
                len(self.spec_idx),
                self.chanstart,
                self.chanend,
            )
        elif self.bit_mode == 1:
            self.pol0, self.pol1 = unpk.unpack_1bit(
                self.raw_data, self.length_channels, self.chanstart, self.chanend
            )
        else:
            print(&#34;Unknown bit depth&#34;)


class BasebandPacked(Baseband):
    # turn spec_selection to true and enter the range of spectra you want to save only part of the file
    def __init__(
        self,
        file_name,
        readlen=-1,
        fixoverflow=True,
        rowstart=None,
        rowend=None,
        chanstart=0,
        chanend=None,
        unpack=True,
    ):
        super().__init__(file_name, readlen)

        # self.spec_idx2 = self.spec_num - self.spec_num[0]
        self.chanstart = chanstart
        if chanend == None:
            self.chanend = self.length_channels
        else:
            self.chanend = chanend

        if unpack:
            if rowstart and rowend:
                self.pol0, self.pol1 = self._unpack(rowstart, rowend)
            else:
                self.pol0, self.pol1 = self._unpack(0, len(self.spec_idx))

    def _unpack(self, rowstart, rowend):
        # There should NOT be an option to modify channels you&#39;re working with in a private function.
        # If you want different set of channels, create a new object
        return unpk.sortpols(
            self.raw_data,
            self.length_channels,
            self.bit_mode,
            rowstart,
            rowend,
            self.chanstart,
            self.chanend,
        )


def get_rows_from_specnum(stidx, endidx, spec_arr):
    # follows numpy convention
    # endidx is assumed not included
    # print(&#34;utils get_rows received:&#34;,stidx,endidx,spec_arr)
    l = numpy.searchsorted(spec_arr, stidx, side=&#34;left&#34;)
    r = numpy.searchsorted(spec_arr, endidx, side=&#34;left&#34;)
    return l, r


class BasebandFileIterator:
    def __init__(
        self,
        file_paths,
        fileidx,
        idxstart,
        acclen,
        nchunks=None,
        chanstart=0,
        chanend=None,
    ):
        # you need to pass nchunks if you are passing the iterator to zip(). without nchunks, iteration won&#39;t stop
        print(&#34;ACCLEN RECEIVED IS&#34;, acclen)
        self._OVERFLOW_DICT = {}
        self._OVERFLOW_CTR = 0
        self.acclen = acclen
        self.file_paths = file_paths
        self.fileidx = fileidx
        self.nchunks = nchunks
        self.chunksread = 0
        self.chanstart = chanstart
        self.chanend = chanend
        self.obj = BasebandPacked(
            file_paths[fileidx], chanstart=chanstart, chanend=chanend, unpack=False
        )
        self.spec_num_start = (
            idxstart + self.obj.spec_idx[0]
        )  # REPLACE SPEC_IDX to be SPEC_NUM, not 0 indexed
        print(
            &#34;START SPECNUM IS&#34;,
            self.spec_num_start,
            &#34;obj start at&#34;,
            self.obj.spec_num[0],
        )
        if self.obj.bit_mode == 4:
            self.ncols = (
                self.obj.chanend - self.obj.chanstart
            )  # gotta be careful with this for 1 bit and 2 bit. for 4 bits, ncols = nchans
        elif self.obj.bit_mode == 1:
            if self.obj.chanstart % 2 &gt; 0:
                raise ValueError(&#34;ERROR: Start channel index must be even.&#34;)
            self.ncols = numpy.ceil((self.obj.chanend - self.obj.chanstart) / 4).astype(
                int
            )

    def _read_packed(
        self,
        file_name,
        readlen=-1,
        fixoverflow=True,
        rowstart=None,
        rowend=None,
        chanstart=0,
        chanend=None,
        unpack=True,
    ):
        temp_obj = BasebandPacked(
            file_name,
            fixoverflow=False,
            chanstart=chanstart,
            chanend=chanend,
            unpack=False,
        )
        temp_obj.spec_num[:] += (
            self._OVERFLOW_CNTR * 2**32
        )  # correct for past overflows in this run of averaging
        if len(temp_obj.where_zero) == 1:
            if file_name not in self._OVERFLOW_DICT.keys():
                self._OVERFLOW_DICT[file_name] = 1
                self._OVERFLOW_CTR += 1
                temp_obj.spec_num[temp_obj.where_zero[0] + 1 :] += 2**32
            elif len(temp_obj.where_zero) &gt; 1:
                raise ValueError(
                    f&#34;Why are there two -ve diffs in specnum? Investigate {file_name}&#34;
                )
        temp_obj._set_specidx()
        return temp_obj

    def __iter__(self):
        return self

    def __next__(self):
        t1 = time.time()
        print(
            &#34;Current obj first spec vs acc start&#34;,
            self.obj.spec_idx[0],
            self.spec_num_start,
        )
        if self.nchunks and self.chunksread == self.nchunks:
            raise StopIteration
        pol0 = numpy.zeros(
            (self.acclen, self.ncols), dtype=&#34;uint8&#34;, order=&#34;c&#34;
        )  # for now take all channels. will modify to accept chanstart, chanend
        pol1 = numpy.zeros((self.acclen, self.ncols), dtype=&#34;uint8&#34;, order=&#34;c&#34;)
        specnums = numpy.array(
            [], dtype=&#34;int64&#34;
        )  # len of this array will control everything in corr, neeeeed the len.
        rem = self.acclen
        i = 0
        while rem:
            print(&#34;Rem is&#34;, rem)
            if self.spec_num_start &lt; self.obj.spec_num[0]:
                # we are in a gap between the files
                print(&#34;IN A GAP BETWEEN FILES&#34;)
                step = min(self.obj.spec_num[0] - self.spec_num_start, rem)
                rem -= step
                # i+=self.acclen-rem
                self.spec_num_start += step
            else:
                l = (
                    self.obj.spec_idx[-1] - self.spec_num_start + 1
                )  # length to end from the point in file we&#39;re starting from
                # print(&#34;dist to end is&#34;, l, &#34;rem is&#34;, rem)
                if rem &gt;= l:
                    # spillover to next file.

                    rowstart, rowend = get_rows_from_specnum(
                        self.spec_num_start, self.spec_num_start + l, self.obj.spec_idx
                    )
                    print(
                        &#34;From if:, rowstart, rowend&#34;,
                        rowstart,
                        rowend,
                        rowend - rowstart,
                    )
                    specnums = numpy.append(
                        specnums, self.obj.spec_idx[rowstart:rowend]
                    )
                    # print(&#34;len specnum from new file&#34;, rowend-rowstart)
                    rem -= l
                    (
                        pol0[i : i + rowend - rowstart],
                        pol1[i : i + rowend - rowstart],
                    ) = self.obj._unpack(rowstart, rowend)
                    i += rowend - rowstart
                    self.spec_num_start += l
                    # print(&#34;Reading new file&#34;)
                    self.fileidx += 1
                    self.obj = BasebandPacked(
                        self.file_paths[self.fileidx],
                        chanstart=self.chanstart,
                        chanend=self.chanend,
                        unpack=False,
                    )
                    print(
                        &#34;My specnum pointer at&#34;,
                        self.spec_num_start,
                        &#34;first specnum of new obj&#34;,
                        self.obj.spec_num[0],
                    )
                else:
                    rowstart, rowend = get_rows_from_specnum(
                        self.spec_num_start,
                        self.spec_num_start + rem,
                        self.obj.spec_idx,
                    )
                    print(
                        &#34;From else:, rowstart, rowend&#34;,
                        rowstart,
                        rowend,
                        rowend - rowstart,
                    )
                    specnums = numpy.append(
                        specnums, self.obj.spec_idx[rowstart:rowend]
                    )
                    # print(&#34;len specnum from else&#34;, rowend-rowstart)
                    (
                        pol0[i : i + rowend - rowstart],
                        pol1[i : i + rowend - rowstart],
                    ) = self.obj._unpack(rowstart, rowend)
                    self.spec_num_start += rem
                    rem = 0
                    i += rowend - rowstart
        # print(pol0[len(specnums)-1,:])
        # print(pol0[len(specnums),:])
        self.chunksread += 1
        data = {&#34;pol0&#34;: pol0, &#34;pol1&#34;: pol1, &#34;specnums&#34;: specnums}
        t2 = time.time()
        # print(&#34;TIME TAKEN FOR RETURNING NEW OBJECT&#34;,t2-t1)
        return data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="albatros_analysis.correlations.baseband_data_classes.fill_arr"><code class="name flex">
<span>def <span class="ident">fill_arr</span></span>(<span>myarr, specnum, spec_per_packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@nb.njit(parallel=True)
def fill_arr(myarr, specnum, spec_per_packet):
    n = len(specnum)
    for i in nb.prange(n):
        for j in nb.prange(spec_per_packet):
            myarr[i * spec_per_packet + j] = specnum[i] + j</code></pre>
</details>
</dd>
<dt id="albatros_analysis.correlations.baseband_data_classes.get_header"><code class="name flex">
<span>def <span class="ident">get_header</span></span>(<span>file_name, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_header(file_name, verbose=True):
    obj = Baseband(file_name, readlen=0)
    if verbose:
        obj.print_header()
    return obj.__dict__</code></pre>
</details>
</dd>
<dt id="albatros_analysis.correlations.baseband_data_classes.get_rows_from_specnum"><code class="name flex">
<span>def <span class="ident">get_rows_from_specnum</span></span>(<span>stidx, endidx, spec_arr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rows_from_specnum(stidx, endidx, spec_arr):
    # follows numpy convention
    # endidx is assumed not included
    # print(&#34;utils get_rows received:&#34;,stidx,endidx,spec_arr)
    l = numpy.searchsorted(spec_arr, stidx, side=&#34;left&#34;)
    r = numpy.searchsorted(spec_arr, endidx, side=&#34;left&#34;)
    return l, r</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="albatros_analysis.correlations.baseband_data_classes.Baseband"><code class="flex name class">
<span>class <span class="ident">Baseband</span></span>
<span>(</span><span>file_name, readlen=-1, fixoverflow=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Baseband:
    def __init__(self, file_name, readlen=-1, fixoverflow=True):
        with open(file_name, &#34;rb&#34;) as file_data:  # ,encoding=&#39;ascii&#39;)
            header_bytes = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            # setting all the header values
            self.header_bytes = 8 + header_bytes
            self.bytes_per_packet = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.length_channels = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.spectra_per_packet = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.bit_mode = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.have_trimble = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.channels = numpy.frombuffer(
                file_data.read(self.header_bytes - 88),
                &#34;&gt;%dQ&#34; % (int((header_bytes - 8 * 10) / 8)),
            )[
                0
            ]  # this line is sketchy but it should work as long as the header structure stays the same. I know there&#39;s 88 bytes of the header which is not the channel array, so the rest is the length of the channel array.
            self.gps_week = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.gps_timestamp = struct.unpack(&#34;&gt;Q&#34;, file_data.read(8))[0]
            self.gps_latitude = struct.unpack(&#34;&gt;d&#34;, file_data.read(8))[0]
            self.gps_longitude = struct.unpack(&#34;&gt;d&#34;, file_data.read(8))[0]
            self.gps_elevation = struct.unpack(&#34;&gt;d&#34;, file_data.read(8))[0]
            self.specnum_overflow = 0

            if self.bit_mode == 1:
                self.channels = numpy.ravel(
                    numpy.column_stack((self.channels, self.channels + 1))
                )
                self.length_channels = int(self.length_channels * 2)
            if self.bit_mode == 4:
                self.channels = self.channels[::2]
                self.length_channels = int(self.length_channels / 2)

            self.num_packets = (
                os.fstat(file_data.fileno()).st_size - self.header_bytes
            ) // self.bytes_per_packet
            if readlen &gt;= 1:
                # interpreted as number of packets
                self.read_packets = int(readlen)
                print(&#34;Reading&#34;, self.read_packets, &#34;packets&#34;)
            elif readlen &gt; 0 and readlen &lt; 1:
                # fraction of file
                self.read_packets = int(self.num_packets * readlen)
                print(&#34;Reading&#34;, self.read_packets, &#34;packets&#34;)
            elif readlen == 0:
                print(&#34;Not reading any data&#34;)
                self.read_packets = 0
            else:
                self.read_packets = -1

            if self.read_packets != 0:
                file_data.seek(self.header_bytes)
                t1 = time.time()
                data = numpy.fromfile(
                    file_data,
                    count=self.read_packets,
                    dtype=[
                        (&#34;spec_num&#34;, &#34;&gt;I&#34;),
                        (&#34;spectra&#34;, &#34;%dB&#34; % (self.bytes_per_packet - 4)),
                    ],
                )
                t2 = time.time()
                print(f&#34;took {t2-t1:5.3f} seconds to read raw data on &#34;, file_name)
                self.raw_data = numpy.array(data[&#34;spectra&#34;], dtype=&#34;uint8&#34;)
                self.spec_num = numpy.array(data[&#34;spec_num&#34;], dtype=&#34;int64&#34;)
                # check for specnum overflow in current file
                self.where_zero = np.where(np.diff(self.spec_num) &lt; 0)[0]
                if fixoverflow:
                    if len(self.where_zero) == 1:
                        self.spec_num[self.where_zero[0] + 1 :] += 2**32
                        self._set_specidx()
                    elif len(self.where_zero) &gt; 1:
                        raise ValueError(
                            &#34;Why are there two -ve diffs in specnum? Investigate this file&#34;
                        )
                self._set_specidx()

    def _set_specidx(self):
        self.spec_idx = numpy.zeros(
            self.spec_num.shape[0] * self.spectra_per_packet, dtype=&#34;int64&#34;
        )  # keep dtype int64 otherwise numpy binary search becomes slow
        fill_arr(self.spec_idx, self.spec_num, self.spectra_per_packet)
        specdiff = numpy.diff(self.spec_num)
        idx = numpy.where(specdiff != self.spectra_per_packet)[0]
        self.missing_loc = (
            self.spec_num[idx] + self.spectra_per_packet - self.spec_num[0]
        ).astype(&#34;int64&#34;)
        self.missing_num = (specdiff[idx] - self.spectra_per_packet).astype(&#34;int64&#34;)

    def print_header(self):
        print(
            &#34;Header Bytes = &#34;
            + str(self.header_bytes)
            + &#34;. Bytes per packet = &#34;
            + str(self.bytes_per_packet)
            + &#34;. Channel length = &#34;
            + str(self.length_channels)
            + &#34;. Spectra per packet: &#34;
            + str(self.spectra_per_packet)
            + &#34;. Bit mode: &#34;
            + str(self.bit_mode)
            + &#34;. Total packets = &#34;
            + str(self.num_packets)
            + &#34;. Read packets = &#34;
            + str(self.read_packets)
            + &#34;. Have trimble = &#34;
            + str(self.have_trimble)
            + &#34;. Channels: &#34;
            + str(self.channels)
            + &#34; GPS week = &#34;
            + str(self.gps_week)
            + &#34;. GPS timestamp = &#34;
            + str(self.gps_timestamp)
            + &#34;. GPS latitude = &#34;
            + str(self.gps_latitude)
            + &#34;. GPS longitude = &#34;
            + str(self.gps_longitude)
            + &#34;. GPS elevation = &#34;
            + str(self.gps_elevation)
            + &#34;.&#34;
        )

    def get_hist(self, mode=-1):
        # mode = 0 for pol0, 1 for pol1, -1 for both
        rowstart = 0
        rowend = len(self.spec_idx)
        return unpk.hist(
            self.raw_data, rowstart, rowend, self.length_channels, self.bit_mode, mode
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="albatros_analysis.correlations.baseband_data_classes.BasebandFloat" href="#albatros_analysis.correlations.baseband_data_classes.BasebandFloat">BasebandFloat</a></li>
<li><a title="albatros_analysis.correlations.baseband_data_classes.BasebandPacked" href="#albatros_analysis.correlations.baseband_data_classes.BasebandPacked">BasebandPacked</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="albatros_analysis.correlations.baseband_data_classes.Baseband.get_hist"><code class="name flex">
<span>def <span class="ident">get_hist</span></span>(<span>self, mode=-1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hist(self, mode=-1):
    # mode = 0 for pol0, 1 for pol1, -1 for both
    rowstart = 0
    rowend = len(self.spec_idx)
    return unpk.hist(
        self.raw_data, rowstart, rowend, self.length_channels, self.bit_mode, mode
    )</code></pre>
</details>
</dd>
<dt id="albatros_analysis.correlations.baseband_data_classes.Baseband.print_header"><code class="name flex">
<span>def <span class="ident">print_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_header(self):
    print(
        &#34;Header Bytes = &#34;
        + str(self.header_bytes)
        + &#34;. Bytes per packet = &#34;
        + str(self.bytes_per_packet)
        + &#34;. Channel length = &#34;
        + str(self.length_channels)
        + &#34;. Spectra per packet: &#34;
        + str(self.spectra_per_packet)
        + &#34;. Bit mode: &#34;
        + str(self.bit_mode)
        + &#34;. Total packets = &#34;
        + str(self.num_packets)
        + &#34;. Read packets = &#34;
        + str(self.read_packets)
        + &#34;. Have trimble = &#34;
        + str(self.have_trimble)
        + &#34;. Channels: &#34;
        + str(self.channels)
        + &#34; GPS week = &#34;
        + str(self.gps_week)
        + &#34;. GPS timestamp = &#34;
        + str(self.gps_timestamp)
        + &#34;. GPS latitude = &#34;
        + str(self.gps_latitude)
        + &#34;. GPS longitude = &#34;
        + str(self.gps_longitude)
        + &#34;. GPS elevation = &#34;
        + str(self.gps_elevation)
        + &#34;.&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="albatros_analysis.correlations.baseband_data_classes.BasebandFileIterator"><code class="flex name class">
<span>class <span class="ident">BasebandFileIterator</span></span>
<span>(</span><span>file_paths, fileidx, idxstart, acclen, nchunks=None, chanstart=0, chanend=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasebandFileIterator:
    def __init__(
        self,
        file_paths,
        fileidx,
        idxstart,
        acclen,
        nchunks=None,
        chanstart=0,
        chanend=None,
    ):
        # you need to pass nchunks if you are passing the iterator to zip(). without nchunks, iteration won&#39;t stop
        print(&#34;ACCLEN RECEIVED IS&#34;, acclen)
        self._OVERFLOW_DICT = {}
        self._OVERFLOW_CTR = 0
        self.acclen = acclen
        self.file_paths = file_paths
        self.fileidx = fileidx
        self.nchunks = nchunks
        self.chunksread = 0
        self.chanstart = chanstart
        self.chanend = chanend
        self.obj = BasebandPacked(
            file_paths[fileidx], chanstart=chanstart, chanend=chanend, unpack=False
        )
        self.spec_num_start = (
            idxstart + self.obj.spec_idx[0]
        )  # REPLACE SPEC_IDX to be SPEC_NUM, not 0 indexed
        print(
            &#34;START SPECNUM IS&#34;,
            self.spec_num_start,
            &#34;obj start at&#34;,
            self.obj.spec_num[0],
        )
        if self.obj.bit_mode == 4:
            self.ncols = (
                self.obj.chanend - self.obj.chanstart
            )  # gotta be careful with this for 1 bit and 2 bit. for 4 bits, ncols = nchans
        elif self.obj.bit_mode == 1:
            if self.obj.chanstart % 2 &gt; 0:
                raise ValueError(&#34;ERROR: Start channel index must be even.&#34;)
            self.ncols = numpy.ceil((self.obj.chanend - self.obj.chanstart) / 4).astype(
                int
            )

    def _read_packed(
        self,
        file_name,
        readlen=-1,
        fixoverflow=True,
        rowstart=None,
        rowend=None,
        chanstart=0,
        chanend=None,
        unpack=True,
    ):
        temp_obj = BasebandPacked(
            file_name,
            fixoverflow=False,
            chanstart=chanstart,
            chanend=chanend,
            unpack=False,
        )
        temp_obj.spec_num[:] += (
            self._OVERFLOW_CNTR * 2**32
        )  # correct for past overflows in this run of averaging
        if len(temp_obj.where_zero) == 1:
            if file_name not in self._OVERFLOW_DICT.keys():
                self._OVERFLOW_DICT[file_name] = 1
                self._OVERFLOW_CTR += 1
                temp_obj.spec_num[temp_obj.where_zero[0] + 1 :] += 2**32
            elif len(temp_obj.where_zero) &gt; 1:
                raise ValueError(
                    f&#34;Why are there two -ve diffs in specnum? Investigate {file_name}&#34;
                )
        temp_obj._set_specidx()
        return temp_obj

    def __iter__(self):
        return self

    def __next__(self):
        t1 = time.time()
        print(
            &#34;Current obj first spec vs acc start&#34;,
            self.obj.spec_idx[0],
            self.spec_num_start,
        )
        if self.nchunks and self.chunksread == self.nchunks:
            raise StopIteration
        pol0 = numpy.zeros(
            (self.acclen, self.ncols), dtype=&#34;uint8&#34;, order=&#34;c&#34;
        )  # for now take all channels. will modify to accept chanstart, chanend
        pol1 = numpy.zeros((self.acclen, self.ncols), dtype=&#34;uint8&#34;, order=&#34;c&#34;)
        specnums = numpy.array(
            [], dtype=&#34;int64&#34;
        )  # len of this array will control everything in corr, neeeeed the len.
        rem = self.acclen
        i = 0
        while rem:
            print(&#34;Rem is&#34;, rem)
            if self.spec_num_start &lt; self.obj.spec_num[0]:
                # we are in a gap between the files
                print(&#34;IN A GAP BETWEEN FILES&#34;)
                step = min(self.obj.spec_num[0] - self.spec_num_start, rem)
                rem -= step
                # i+=self.acclen-rem
                self.spec_num_start += step
            else:
                l = (
                    self.obj.spec_idx[-1] - self.spec_num_start + 1
                )  # length to end from the point in file we&#39;re starting from
                # print(&#34;dist to end is&#34;, l, &#34;rem is&#34;, rem)
                if rem &gt;= l:
                    # spillover to next file.

                    rowstart, rowend = get_rows_from_specnum(
                        self.spec_num_start, self.spec_num_start + l, self.obj.spec_idx
                    )
                    print(
                        &#34;From if:, rowstart, rowend&#34;,
                        rowstart,
                        rowend,
                        rowend - rowstart,
                    )
                    specnums = numpy.append(
                        specnums, self.obj.spec_idx[rowstart:rowend]
                    )
                    # print(&#34;len specnum from new file&#34;, rowend-rowstart)
                    rem -= l
                    (
                        pol0[i : i + rowend - rowstart],
                        pol1[i : i + rowend - rowstart],
                    ) = self.obj._unpack(rowstart, rowend)
                    i += rowend - rowstart
                    self.spec_num_start += l
                    # print(&#34;Reading new file&#34;)
                    self.fileidx += 1
                    self.obj = BasebandPacked(
                        self.file_paths[self.fileidx],
                        chanstart=self.chanstart,
                        chanend=self.chanend,
                        unpack=False,
                    )
                    print(
                        &#34;My specnum pointer at&#34;,
                        self.spec_num_start,
                        &#34;first specnum of new obj&#34;,
                        self.obj.spec_num[0],
                    )
                else:
                    rowstart, rowend = get_rows_from_specnum(
                        self.spec_num_start,
                        self.spec_num_start + rem,
                        self.obj.spec_idx,
                    )
                    print(
                        &#34;From else:, rowstart, rowend&#34;,
                        rowstart,
                        rowend,
                        rowend - rowstart,
                    )
                    specnums = numpy.append(
                        specnums, self.obj.spec_idx[rowstart:rowend]
                    )
                    # print(&#34;len specnum from else&#34;, rowend-rowstart)
                    (
                        pol0[i : i + rowend - rowstart],
                        pol1[i : i + rowend - rowstart],
                    ) = self.obj._unpack(rowstart, rowend)
                    self.spec_num_start += rem
                    rem = 0
                    i += rowend - rowstart
        # print(pol0[len(specnums)-1,:])
        # print(pol0[len(specnums),:])
        self.chunksread += 1
        data = {&#34;pol0&#34;: pol0, &#34;pol1&#34;: pol1, &#34;specnums&#34;: specnums}
        t2 = time.time()
        # print(&#34;TIME TAKEN FOR RETURNING NEW OBJECT&#34;,t2-t1)
        return data</code></pre>
</details>
</dd>
<dt id="albatros_analysis.correlations.baseband_data_classes.BasebandFloat"><code class="flex name class">
<span>class <span class="ident">BasebandFloat</span></span>
<span>(</span><span>file_name, readlen=-1, fixoverflow=True, chanstart=0, chanend=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasebandFloat(Baseband):
    def __init__(
        self, file_name, readlen=-1, fixoverflow=True, chanstart=0, chanend=None
    ):
        super().__init__(file_name, readlen)
        self.chanstart = chanstart
        if chanend == None:
            self.chanend = self.length_channels
        else:
            self.chanend = chanend

        if self.bit_mode == 4:
            self.pol0, self.pol1 = unpk.unpack_4bit(
                self.raw_data,
                self.length_channels,
                0,
                len(self.spec_idx),
                self.chanstart,
                self.chanend,
            )
        elif self.bit_mode == 1:
            self.pol0, self.pol1 = unpk.unpack_1bit(
                self.raw_data, self.length_channels, self.chanstart, self.chanend
            )
        else:
            print(&#34;Unknown bit depth&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="albatros_analysis.correlations.baseband_data_classes.Baseband" href="#albatros_analysis.correlations.baseband_data_classes.Baseband">Baseband</a></li>
</ul>
</dd>
<dt id="albatros_analysis.correlations.baseband_data_classes.BasebandPacked"><code class="flex name class">
<span>class <span class="ident">BasebandPacked</span></span>
<span>(</span><span>file_name, readlen=-1, fixoverflow=True, rowstart=None, rowend=None, chanstart=0, chanend=None, unpack=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasebandPacked(Baseband):
    # turn spec_selection to true and enter the range of spectra you want to save only part of the file
    def __init__(
        self,
        file_name,
        readlen=-1,
        fixoverflow=True,
        rowstart=None,
        rowend=None,
        chanstart=0,
        chanend=None,
        unpack=True,
    ):
        super().__init__(file_name, readlen)

        # self.spec_idx2 = self.spec_num - self.spec_num[0]
        self.chanstart = chanstart
        if chanend == None:
            self.chanend = self.length_channels
        else:
            self.chanend = chanend

        if unpack:
            if rowstart and rowend:
                self.pol0, self.pol1 = self._unpack(rowstart, rowend)
            else:
                self.pol0, self.pol1 = self._unpack(0, len(self.spec_idx))

    def _unpack(self, rowstart, rowend):
        # There should NOT be an option to modify channels you&#39;re working with in a private function.
        # If you want different set of channels, create a new object
        return unpk.sortpols(
            self.raw_data,
            self.length_channels,
            self.bit_mode,
            rowstart,
            rowend,
            self.chanstart,
            self.chanend,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="albatros_analysis.correlations.baseband_data_classes.Baseband" href="#albatros_analysis.correlations.baseband_data_classes.Baseband">Baseband</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="albatros_analysis.correlations" href="index.html">albatros_analysis.correlations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="albatros_analysis.correlations.baseband_data_classes.fill_arr" href="#albatros_analysis.correlations.baseband_data_classes.fill_arr">fill_arr</a></code></li>
<li><code><a title="albatros_analysis.correlations.baseband_data_classes.get_header" href="#albatros_analysis.correlations.baseband_data_classes.get_header">get_header</a></code></li>
<li><code><a title="albatros_analysis.correlations.baseband_data_classes.get_rows_from_specnum" href="#albatros_analysis.correlations.baseband_data_classes.get_rows_from_specnum">get_rows_from_specnum</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="albatros_analysis.correlations.baseband_data_classes.Baseband" href="#albatros_analysis.correlations.baseband_data_classes.Baseband">Baseband</a></code></h4>
<ul class="">
<li><code><a title="albatros_analysis.correlations.baseband_data_classes.Baseband.get_hist" href="#albatros_analysis.correlations.baseband_data_classes.Baseband.get_hist">get_hist</a></code></li>
<li><code><a title="albatros_analysis.correlations.baseband_data_classes.Baseband.print_header" href="#albatros_analysis.correlations.baseband_data_classes.Baseband.print_header">print_header</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="albatros_analysis.correlations.baseband_data_classes.BasebandFileIterator" href="#albatros_analysis.correlations.baseband_data_classes.BasebandFileIterator">BasebandFileIterator</a></code></h4>
</li>
<li>
<h4><code><a title="albatros_analysis.correlations.baseband_data_classes.BasebandFloat" href="#albatros_analysis.correlations.baseband_data_classes.BasebandFloat">BasebandFloat</a></code></h4>
</li>
<li>
<h4><code><a title="albatros_analysis.correlations.baseband_data_classes.BasebandPacked" href="#albatros_analysis.correlations.baseband_data_classes.BasebandPacked">BasebandPacked</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>