<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>albatros_analysis.harmonic_finder API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>albatros_analysis.harmonic_finder</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

# from acoustics.cepstrum import complex_cepstrum
import os, argparse
from scio import scio
import matplotlib.pyplot as plt

from astropy.convolution import Gaussian1DKernel
from astropy.convolution import convolve

from scipy.interpolate import interp1d
import scipy.signal as signal
from scipy.integrate import quad

from palettable.cartocolors.qualitative import Safe_10


def triangle(start, stop, freqs):
    &#34;&#34;&#34;Function which returns a single triangle window with designated start and stop.
    Input: start, the start frequency
           stop, the stop frequency
           freqs, an array of the freqs over which the triangle window will be applies
    &#34;&#34;&#34;
    mid = (stop + start) / 2
    to_return = np.zeros(len(freqs))
    for i in range(len(freqs)):
        if freqs[i] &lt; start or freqs[i] &gt; stop:
            continue
        elif freqs[i] &lt;= mid:
            to_return[i] = (freqs[i] - start) / (mid - start)
        elif freqs[i] &gt; mid:
            to_return[i] = (freqs[i] - stop) / (mid - stop)

    return to_return


def get_Hb(freqs, nb=30):
    &#34;&#34;&#34;Function for generating the power response function Hb from klapuri06
    Inputs: freqs, the frequencies associated with x
            nb, the number of subbands
    Outputs: Hb, the responses
    &#34;&#34;&#34;
    bs = np.arange(0, nb + 2, 1)
    cb = 229 * (10 ** ((1 + bs) / (21.4)) - 1) * 1.80e4
    Hb = np.zeros((len(freqs), nb))
    for i in range(1, nb + 1):
        Hb[..., i - 1] = triangle(cb[i - 1], cb[i + 1], freqs)

    return Hb, cb[1:-1]


def whittener(x, freqs, nu=0.33, nb=30):
    &#34;&#34;&#34;Spectral whittening function from Klapuri06: https://www.ee.columbia.edu/~dpwe/papers/Klap06-multif0.pdf
    Input: x, the spectrum to be whitened
           nu, a whittening scaling parameter
    Reutrns: gamma(f), the whittening function as a function of frequency.
    &#34;&#34;&#34;
    Hb, cb = get_Hb(freqs=freqs, nb=nb)
    sigma_bs = np.zeros(len(cb))

    for i in range(len(sigma_bs)):
        sigma_bs[i] = np.sqrt(1 / len(x) * sum(Hb[..., i] * np.abs(x) ** 2))

    yb = sigma_bs ** (nu - 1)

    return interp1d(cb, yb, fill_value=&#34;extrapolate&#34;)


def gaussian(x, mu, sig):
    return np.exp(-np.power(x - mu, 2.0) / (2 * np.power(sig, 2.0)))


def simple_harm_sweep(
    x,
    freqs,
    fmin=None,
    fmax=None,
    numf=1e5,
    harm_min=1,
    harm_max=5,
    window_size=None,
    interp=None,
):
    &#34;&#34;&#34;This function takes a spectrum and applies a harmonic comb to it, identifying which frequencies f are present in the spectrum at 1*f, 2*f, 3*f, etc. Useful when you suspect that there is a harmonic series present in a spectrum, and would like to identify what the fundamentals are

     Input: x, the spectrum to be considered
            freqs, the coresponding frequencies of the spectrum
            fmin, the minimum fundamental frequency to consider
            fmax, the maximum fundamental frequency to consider
            numf, the number of points in fundamental frequency space to sample
            harm_min, the lowest harmonic on the frequency comb. harm_min=1 gives the simplest case where we begin the comb at the fundamental, harm_min = 2 starts with the second harmonic, etc.
            harm_max, the highest harmonic of the comb. Including too many harmonics washes out the comb power
            window, depreciated, type of window by which the spectrum is smoothed. Superceded by whittening, but kept in case we want to return to smoothing
            interp, how to interpolate the spectrum for applying the comb. If none, no interpolation is performed
    Returns: fspace if interp, else freqs. The fundamental frequencies. When no interpolating, this is the same as the input frequencies.
             to_return, the comb response at fspace/freqs, normalized by the average spectrum.
    &#34;&#34;&#34;

    if fmin is None:
        fmin = min(freqs)
    if fmax is None:
        fmax = max(freqs)
    numf = int(numf)

    if interp:
        fspace = np.linspace(fmin, fmax, numf)
        interp_x = interp1d(freqs, x, kind=interp)
        to_return = np.zeros(len(fspace))
        for i in range(len(to_return) - 1):
            # Don&#39;t look at more than some number of  harmonics since it washes out the power
            harm_freqs = np.arange(
                harm_min * fspace[i], min(max(freqs), harm_max * fspace[i]), fspace[i]
            )

            if window_size is None:
                to_return[i] = interp_x(harm_freqs).sum() / len(harm_freqs)
            else:
                gaus_window = lambda x: gaussian(
                    x, harm_freqs[:, None], window_size
                ).sum(axis=0)
                integrand = lambda x: interp_x(x) * gaus_window(x)
                to_return[i] = (
                    quad(integrand, min(freqs), max(freqs))[0]
                    / quad(gaus_window, min(freqs), max(freqs))[0]
                )
        return fspace, to_return / np.mean(x)

    else:
        to_return = np.zeros(len(x))
        index_fmin = int(np.floor(fmin / (freqs[1] - freqs[0])))
        index_fmax = int(np.floor(fmax / (freqs[1] - freqs[0])))

        # for i in range(10, int(len(x)/2)):
        for i in range(index_fmin, index_fmax):
            index_harm_min = int(np.floor((i + 1) * harm_min))
            index_harm_max = min((i + 1) * harm_max, len(x))
            to_return[i] = x[i:index_harm_max:i].sum() / len(
                range(i, index_harm_max, i)
            )

    return freqs, to_return / np.mean(x)


def _parse_slice(s):
    a = [int(e) if e.strip() else None for e in s.split(&#34;:&#34;)]
    return slice(*a)


def get_acctime(fpath):
    dat = np.fromfile(fpath, dtype=&#34;uint32&#34;)
    diff = np.diff(dat)
    acctime = np.mean(
        diff[(diff &gt; 0) &amp; (diff &lt; 100)]
    )  # sometimes timestamps are 0, which causes diff to be huge. could also use np. median
    return acctime


if __name__ == &#34;__main__&#34;:
    &#34;Example usage: python harmonic_finder.py -sl=14:15  ~/albatros_data/uapishka_april_23/data_auto_cross/16807/1680755638/&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;data_dir&#34;,
        type=str,
        help=&#34;Auto/cross-spectra location. Ex: ~/data_auto_cross/16171/161700000&#34;,
    )
    parser.add_argument(
        &#34;-o&#34;, &#34;--output_dir&#34;, type=str, default=&#34;./&#34;, help=&#34;Output directory for plots&#34;
    )
    parser.add_argument(
        &#34;-sl&#34;,
        &#34;--tslice&#34;,
        type=_parse_slice,
        help=&#34;Slice on time axis to restrict plot to. Format: -sl=tmin:tmax for timin, tmax in minutes&#34;,
    )
    parser.add_argument(
        &#34;-st&#34;,
        &#34;--stattype&#34;,
        type=str,
        default=&#34;mean&#34;,
        help=&#34;Statisitcal method for reducing the data long time axis. Options are median or mean&#34;,
    )
    parser.add_argument(&#34;-si&#34;, &#34;--sim&#34;, type=int, default=0, help=&#34;sim&#34;)
    parser.add_argument(
        &#34;-fr&#34;,
        &#34;--freqrange&#34;,
        type=_parse_slice,
        default=slice(5e5, 1e7, 1e5),
        help=&#34;Slice of freqeucny space over which to perform the comb&#34;,
    )
    parser.add_argument(
        &#34;-hr&#34;,
        &#34;--harmrange&#34;,
        type=_parse_slice,
        default=slice(1, 10, 1),
        help=&#34;First and last harmonic to consider in the harmonics comb&#34;,
    )
    parser.add_argument(
        &#34;-nf&#34;,
        &#34;--numf&#34;,
        type=int,
        default=500,
        help=&#34;number of interpolated points over which to comb&#34;,
    )

    args = parser.parse_args()

    pol00 = scio.read(os.path.join(args.data_dir, &#34;pol00.scio.bz2&#34;))
    pol11 = scio.read(os.path.join(args.data_dir, &#34;pol11.scio.bz2&#34;))
    pol01r = scio.read(os.path.join(args.data_dir, &#34;pol01r.scio.bz2&#34;))
    pol01i = scio.read(os.path.join(args.data_dir, &#34;pol01i.scio.bz2&#34;))
    acctime = get_acctime(os.path.join(args.data_dir, &#34;time_gps_start.raw&#34;))

    pol00 = pol00[1:, :]
    pol11 = pol11[1:, :]
    pol01r = pol01r[1:, :]
    pol01i = pol01i[1:, :]

    if args.tslice:
        # convert tslice in minutes to samps
        tstart, tstop, tstep = args.tslice.start, args.tslice.stop, args.tslice.step

        if tstart is not None:
            tstart = int(np.floor(tstart * 60 / acctime))
        if tstop is not None:
            tstop = int(np.floor(tstop * 60 / acctime))
        if tstep is not None:
            tstep = int(np.floor(tstep * 60 / acctime))

        tslice = slice(tstart, tstop, tstep)

        pol00 = pol00[tslice, :]
        pol11 = pol11[tslice, :]
        pol01r = pol01r[tslice, :]
        pol01i = pol01i[tslice, :]

    pol01 = pol01r + 1j * pol01i

    if args.stattype == &#34;mean&#34;:
        pol00_stat = np.mean(pol00, axis=0)
        pol11_stat = np.mean(pol11, axis=0)
    if args.stattype == &#34;max&#34;:
        pol00_stat = np.amax(pol00, axis=0)
        pol11_stat = np.amax(pol11, axis=0)

        pol00_stat = np.array(pol00_stat, dtype=float)
        pol11_stat = np.array(pol11_stat, dtype=float)

    fmin, fmax = args.freqrange.start, args.freqrange.stop
    hmin, hmax = args.harmrange.start, args.harmrange.stop

    numf = args.numf

    t = np.arange(pol00.shape[1]) / 250e6
    freqs = np.arange(0, len(pol00_stat)) * 61035.15

    whittener00 = whittener(pol00_stat, freqs, nu=0.3)
    whittener11 = whittener(pol11_stat, freqs, nu=0.3)

    kernel = Gaussian1DKernel(2)
    # uncomment to smooth the spectrum by kernel before whittening
    # pol00_stat = convolve(pol00_stat, kernel)
    # pol11_stat = convolve(pol11_stat, kernel)
    pol00_unwhite = pol00_stat
    pol11_unwhite = pol11_stat

    pol00_stat = whittener00(freqs) * pol00_stat
    pol11_stat = whittener11(freqs) * pol11_stat

    # Code returns both interpolated and no-interpolated harmonic combs as of now, but they generally give the same results and interpolated is much easier to parse so may just remove the non-interp in the future
    # f00, harm00 = simple_harm_sweep(pol00_stat, freqs, fmin = fmin, fmax = fmax, numf = numf, harm_min = hmin, harm_max = hmax, window_size = None, interp = None)
    # f11, harm11 = simple_harm_sweep(pol11_stat, freqs, fmin = fmin, fmax = fmax, numf = numf, harm_min = hmin, harm_max = hmax, window_size = None, interp = None)

    f00_interp, harm00_interp = simple_harm_sweep(
        pol00_stat,
        freqs,
        fmin=fmin,
        fmax=fmax,
        numf=numf,
        harm_min=hmin,
        harm_max=hmax,
        window_size=None,
        interp=&#34;linear&#34;,
    )
    f11_interp, harm11_interp = simple_harm_sweep(
        pol11_stat,
        freqs,
        fmin=fmin,
        fmax=fmax,
        numf=numf,
        harm_min=hmin,
        harm_max=hmax,
        window_size=None,
        interp=&#34;linear&#34;,
    )

    # Uncomment to smooth the resulting harmonic comb
    # kernel = Gaussian1DKernel((4/500)*numf)
    # harm00 = convolve(harm00, kernel)
    # harm11 = convolve(harm11, kernel)

    harm00_interp = convolve(harm00_interp, kernel)
    harm11_interp = convolve(harm11_interp, kernel)

    # peaks00, peak00_dict = signal.find_peaks(harm00, height = 1e-2, prominence=1e-2, threshold=1e-2)
    # print(&#34;Peaks pol00: &#34;, (f00[peaks00])/1e6,&#34;MHz&#34;)

    # peaks11, peak11_dict = signal.find_peaks(harm11, height = 1e-2, prominence=1e-2, threshold=1e-2)
    # print(&#34;Peaks pol11: &#34;, (f11[peaks11]/1e6),&#34;MHz&#34;)

    peaks00_interp, peak00_dict_interp = signal.find_peaks(
        harm00_interp, height=1e-2, prominence=1e-2, threshold=1e-2
    )
    print(&#34;Peaks pol00 interp: &#34;, (f00_interp[peaks00_interp]) / 1e6, &#34;MHz&#34;)

    peaks11_interp, peak11_dict_interp = signal.find_peaks(
        harm11_interp, height=1e-2, prominence=1e-2, threshold=1e-2
    )
    print(&#34;Peaks pol11 interp: &#34;, (f11_interp[peaks11_interp] / 1e6), &#34;MHz&#34;)

    # f00_max = np.where((harm00 == np.amax(harm00)))[0]
    # f11_max = np.where((harm11 == np.amax(harm11)))[0]
    f00_max_interp = np.where((harm00_interp == np.amax(harm00_interp)))[0]
    f11_max_interp = np.where((harm11_interp == np.amax(harm11_interp)))[0]

    # print(&#34;Tmax pol00: &#34;, f00[f00_max]/1e6)
    # print(&#34;Tmax pol11: &#34;, f11[f11_max]/1e6)
    print(&#34;Tmax pol00 interp: &#34;, f00_interp[f00_max_interp] / 1e6)
    print(&#34;Tmax pol11 interp: &#34;, f11_interp[f11_max_interp] / 1e6)

    colors = np.array(Safe_10.colors) / 256

    timestamp = args.data_dir.split(&#34;/&#34;)[-1]
    &#34;&#34;&#34;
    fig = plt.figure()
    ax0 = fig.add_subplot(211)
    ax0.plot(f00/1e6, harm00)
    ax0.scatter(f00[f00_max]/1e6, harm00[f00_max], marker=&#39;x&#39;, color=&#39;red&#39;, zorder = 1)
    ax0.scatter(f00[peaks00]/1e6, harm00[peaks00], marker=&#39;x&#39;, color=&#39;black&#39;, zorder = 0)
    ax0.set_xlabel(&#39;MHz&#39;)
    ax0.set_yscale(&#39;log&#39;)
    ax0.set_title(&#39;pol00&#39;)
    ax0.set_xlim(0, 10)

    ax1 = fig.add_subplot(212)
    ax1.plot(f11/1e6, harm11)
    ax1.scatter(f11[f11_max]/1e6, harm11[f11_max], marker=&#39;x&#39;, color=&#39;red&#39;, zorder = 1)
    ax1.scatter(f11[peaks11]/1e6, harm11[peaks11], marker=&#39;x&#39;, color=&#39;black&#39;, zorder = 0)
    ax1.set_xlabel(&#39;MHz&#39;)
    ax1.set_yscale(&#39;log&#39;)
    ax1.set_title(&#39;pol11&#39;)
    ax1.set_xlim(0,10)
 
    outfile = os.path.normpath(args.output_dir + &#39;/&#39; + timestamp + &#39;_{}_{}&#39;.format(tstart, tstop) + &#39;.png&#39;)
    print(outfile)
    plt.savefig(outfile)
    plt.close() 
    &#34;&#34;&#34;
    fig = plt.figure(figsize=(14, 6))
    ax0 = fig.add_subplot(221)
    ax0.plot(f00_interp / 1e6, harm00_interp)
    ax0.scatter(
        f00_interp[f00_max_interp] / 1e6,
        harm00_interp[f00_max_interp],
        marker=&#34;x&#34;,
        color=&#34;red&#34;,
        zorder=1,
    )
    ax0.scatter(
        f00_interp[peaks00_interp] / 1e6,
        harm00_interp[peaks00_interp],
        marker=&#34;x&#34;,
        color=&#34;black&#34;,
        zorder=0,
    )
    ax0.set_xlabel(&#34;MHz&#34;)
    ax0.set_yscale(&#34;log&#34;)
    ax0.set_title(&#34;pol00 harmonics&#34;)
    ax0.set_xlim(0, 15)

    ax1 = fig.add_subplot(223)
    ax1.plot(f11_interp / 1e6, harm11_interp)
    ax1.scatter(
        f11_interp[f11_max_interp] / 1e6,
        harm11_interp[f11_max_interp],
        marker=&#34;x&#34;,
        color=&#34;red&#34;,
        zorder=1,
    )
    ax1.scatter(
        f11_interp[peaks11_interp] / 1e6,
        harm11_interp[peaks11_interp],
        marker=&#34;x&#34;,
        color=&#34;black&#34;,
        zorder=0,
    )
    ax1.set_xlabel(&#34;MHz&#34;)
    ax1.set_yscale(&#34;log&#34;)
    ax1.set_title(&#34;pol11 harmonics&#34;)
    ax1.set_xlim(0, 15)

    # Kernel is same as above but can uncomment here to change
    # kernel = Gaussian1DKernel(2)
    pol00_unwhite = convolve(pol00_unwhite, kernel)
    pol11_unwhite = convolve(pol11_unwhite, kernel)

    spectrum00_peaks, _ = signal.find_peaks(
        pol00_unwhite, height=1e7, prominence=1e7, threshold=1e7
    )
    spectrum11_peaks, _ = signal.find_peaks(
        pol11_unwhite, height=1e7, prominence=1e7, threshold=1e7
    )

    ax2 = fig.add_subplot(222)
    ax2.plot(freqs / 1e6, pol00_unwhite)
    ax2.scatter(
        freqs[spectrum00_peaks] / 1e6,
        pol00_unwhite[spectrum00_peaks],
        marker=&#34;x&#34;,
        color=&#34;black&#34;,
    )
    ax2.set_xlabel(&#34;MHz&#34;)
    ax2.set_yscale(&#34;log&#34;)
    ax2.set_title(&#34;pol00 spectrum&#34;)
    ax2.set_xlim(0, 15)
    ax2.set_ylim(1e7, 1e13)

    ax3 = fig.add_subplot(224)
    ax3.plot(freqs / 1e6, pol11_unwhite)
    ax3.scatter(
        freqs[spectrum11_peaks] / 1e6,
        pol11_unwhite[spectrum11_peaks],
        marker=&#34;x&#34;,
        color=&#34;black&#34;,
    )

    ax3.set_xlabel(&#34;MHz&#34;)
    ax3.set_yscale(&#34;log&#34;)
    ax3.set_title(&#34;pol11 spectrum&#34;)
    ax3.set_xlim(0, 15)
    ax3.set_ylim(1e7, 1e13)
    outfile = os.path.normpath(
        args.output_dir
        + &#34;/&#34;
        + timestamp
        + &#34;_{}_{}_combined&#34;.format(tstart, tstop)
        + &#34;.png&#34;
    )

    plt.savefig(outfile)
    plt.close()
    print(outfile)

    print(&#34;pol00&#34;)
    print(&#34;Spectrum peaks&#34;, freqs[spectrum00_peaks] / 1e6)
    print(&#34;Peak diffs: &#34;, np.ediff1d(freqs[spectrum00_peaks] / 1e6))
    print(
        &#34;Peaks div fundamental: &#34;,
        freqs[spectrum00_peaks] / (f00_interp[peaks00_interp][0]),
    )
    print(&#34;Peaks div max: &#34;, freqs[spectrum00_peaks] / f00_interp[f00_max_interp])
    print(&#34;\n&#34;)
    print(&#34;pol11&#34;)
    print(&#34;Spectrum peaks&#34;, freqs[spectrum11_peaks] / 1e6)
    print(&#34;Peak diffs: &#34;, np.ediff1d(freqs[spectrum11_peaks] / 1e6))
    print(
        &#34;Peaks div fundamental: &#34;,
        freqs[spectrum11_peaks] / (f11_interp[peaks11_interp][0]),
    )
    print(&#34;Peaks div max: &#34;, freqs[spectrum11_peaks] / f11_interp[f11_max_interp])

    outfile = os.path.normpath(
        args.output_dir + &#34;/&#34; + timestamp + &#34;_{}_{}_fft&#34;.format(tstart, tstop) + &#34;.png&#34;
    )
    plt.savefig(outfile)


# Some example usage
# python harmonic_finder.py -hr=2:10 -sl=0:60 -o=./plots ~/albatros_data/uapishka_april_23/data_auto_cross/16807/1680766468
# python harmonic_finder.py -hr=2:10 -sl=0:60 -o=./plots ~/albatros_data/uapishka_april_23/data_auto_cross/16808/1680851401
# python harmonic_finder.py -hr=2:10 -sl=0:60 -o=./plots ~/albatros_data/uapishka_april_23/data_auto_cross/16809/1680937220
# python harmonic_finder.py -hr=2:10 -sl=0:60 -o=./plots ~/albatros_data/uapishka_april_23/data_auto_cross/16810/1681023554</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="albatros_analysis.harmonic_finder.gaussian"><code class="name flex">
<span>def <span class="ident">gaussian</span></span>(<span>x, mu, sig)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian(x, mu, sig):
    return np.exp(-np.power(x - mu, 2.0) / (2 * np.power(sig, 2.0)))</code></pre>
</details>
</dd>
<dt id="albatros_analysis.harmonic_finder.get_Hb"><code class="name flex">
<span>def <span class="ident">get_Hb</span></span>(<span>freqs, nb=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for generating the power response function Hb from klapuri06
Inputs: freqs, the frequencies associated with x
nb, the number of subbands
Outputs: Hb, the responses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Hb(freqs, nb=30):
    &#34;&#34;&#34;Function for generating the power response function Hb from klapuri06
    Inputs: freqs, the frequencies associated with x
            nb, the number of subbands
    Outputs: Hb, the responses
    &#34;&#34;&#34;
    bs = np.arange(0, nb + 2, 1)
    cb = 229 * (10 ** ((1 + bs) / (21.4)) - 1) * 1.80e4
    Hb = np.zeros((len(freqs), nb))
    for i in range(1, nb + 1):
        Hb[..., i - 1] = triangle(cb[i - 1], cb[i + 1], freqs)

    return Hb, cb[1:-1]</code></pre>
</details>
</dd>
<dt id="albatros_analysis.harmonic_finder.get_acctime"><code class="name flex">
<span>def <span class="ident">get_acctime</span></span>(<span>fpath)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_acctime(fpath):
    dat = np.fromfile(fpath, dtype=&#34;uint32&#34;)
    diff = np.diff(dat)
    acctime = np.mean(
        diff[(diff &gt; 0) &amp; (diff &lt; 100)]
    )  # sometimes timestamps are 0, which causes diff to be huge. could also use np. median
    return acctime</code></pre>
</details>
</dd>
<dt id="albatros_analysis.harmonic_finder.simple_harm_sweep"><code class="name flex">
<span>def <span class="ident">simple_harm_sweep</span></span>(<span>x, freqs, fmin=None, fmax=None, numf=100000.0, harm_min=1, harm_max=5, window_size=None, interp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes a spectrum and applies a harmonic comb to it, identifying which frequencies f are present in the spectrum at 1<em>f, 2</em>f, 3*f, etc. Useful when you suspect that there is a harmonic series present in a spectrum, and would like to identify what the fundamentals are</p>
<p>Input: x, the spectrum to be considered
freqs, the coresponding frequencies of the spectrum
fmin, the minimum fundamental frequency to consider
fmax, the maximum fundamental frequency to consider
numf, the number of points in fundamental frequency space to sample
harm_min, the lowest harmonic on the frequency comb. harm_min=1 gives the simplest case where we begin the comb at the fundamental, harm_min = 2 starts with the second harmonic, etc.
harm_max, the highest harmonic of the comb. Including too many harmonics washes out the comb power
window, depreciated, type of window by which the spectrum is smoothed. Superceded by whittening, but kept in case we want to return to smoothing
interp, how to interpolate the spectrum for applying the comb. If none, no interpolation is performed
Returns: fspace if interp, else freqs. The fundamental frequencies. When no interpolating, this is the same as the input frequencies.
to_return, the comb response at fspace/freqs, normalized by the average spectrum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_harm_sweep(
    x,
    freqs,
    fmin=None,
    fmax=None,
    numf=1e5,
    harm_min=1,
    harm_max=5,
    window_size=None,
    interp=None,
):
    &#34;&#34;&#34;This function takes a spectrum and applies a harmonic comb to it, identifying which frequencies f are present in the spectrum at 1*f, 2*f, 3*f, etc. Useful when you suspect that there is a harmonic series present in a spectrum, and would like to identify what the fundamentals are

     Input: x, the spectrum to be considered
            freqs, the coresponding frequencies of the spectrum
            fmin, the minimum fundamental frequency to consider
            fmax, the maximum fundamental frequency to consider
            numf, the number of points in fundamental frequency space to sample
            harm_min, the lowest harmonic on the frequency comb. harm_min=1 gives the simplest case where we begin the comb at the fundamental, harm_min = 2 starts with the second harmonic, etc.
            harm_max, the highest harmonic of the comb. Including too many harmonics washes out the comb power
            window, depreciated, type of window by which the spectrum is smoothed. Superceded by whittening, but kept in case we want to return to smoothing
            interp, how to interpolate the spectrum for applying the comb. If none, no interpolation is performed
    Returns: fspace if interp, else freqs. The fundamental frequencies. When no interpolating, this is the same as the input frequencies.
             to_return, the comb response at fspace/freqs, normalized by the average spectrum.
    &#34;&#34;&#34;

    if fmin is None:
        fmin = min(freqs)
    if fmax is None:
        fmax = max(freqs)
    numf = int(numf)

    if interp:
        fspace = np.linspace(fmin, fmax, numf)
        interp_x = interp1d(freqs, x, kind=interp)
        to_return = np.zeros(len(fspace))
        for i in range(len(to_return) - 1):
            # Don&#39;t look at more than some number of  harmonics since it washes out the power
            harm_freqs = np.arange(
                harm_min * fspace[i], min(max(freqs), harm_max * fspace[i]), fspace[i]
            )

            if window_size is None:
                to_return[i] = interp_x(harm_freqs).sum() / len(harm_freqs)
            else:
                gaus_window = lambda x: gaussian(
                    x, harm_freqs[:, None], window_size
                ).sum(axis=0)
                integrand = lambda x: interp_x(x) * gaus_window(x)
                to_return[i] = (
                    quad(integrand, min(freqs), max(freqs))[0]
                    / quad(gaus_window, min(freqs), max(freqs))[0]
                )
        return fspace, to_return / np.mean(x)

    else:
        to_return = np.zeros(len(x))
        index_fmin = int(np.floor(fmin / (freqs[1] - freqs[0])))
        index_fmax = int(np.floor(fmax / (freqs[1] - freqs[0])))

        # for i in range(10, int(len(x)/2)):
        for i in range(index_fmin, index_fmax):
            index_harm_min = int(np.floor((i + 1) * harm_min))
            index_harm_max = min((i + 1) * harm_max, len(x))
            to_return[i] = x[i:index_harm_max:i].sum() / len(
                range(i, index_harm_max, i)
            )

    return freqs, to_return / np.mean(x)</code></pre>
</details>
</dd>
<dt id="albatros_analysis.harmonic_finder.triangle"><code class="name flex">
<span>def <span class="ident">triangle</span></span>(<span>start, stop, freqs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function which returns a single triangle window with designated start and stop.
Input: start, the start frequency
stop, the stop frequency
freqs, an array of the freqs over which the triangle window will be applies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle(start, stop, freqs):
    &#34;&#34;&#34;Function which returns a single triangle window with designated start and stop.
    Input: start, the start frequency
           stop, the stop frequency
           freqs, an array of the freqs over which the triangle window will be applies
    &#34;&#34;&#34;
    mid = (stop + start) / 2
    to_return = np.zeros(len(freqs))
    for i in range(len(freqs)):
        if freqs[i] &lt; start or freqs[i] &gt; stop:
            continue
        elif freqs[i] &lt;= mid:
            to_return[i] = (freqs[i] - start) / (mid - start)
        elif freqs[i] &gt; mid:
            to_return[i] = (freqs[i] - stop) / (mid - stop)

    return to_return</code></pre>
</details>
</dd>
<dt id="albatros_analysis.harmonic_finder.whittener"><code class="name flex">
<span>def <span class="ident">whittener</span></span>(<span>x, freqs, nu=0.33, nb=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Spectral whittening function from Klapuri06: <a href="https://www.ee.columbia.edu/~dpwe/papers/Klap06-multif0.pdf">https://www.ee.columbia.edu/~dpwe/papers/Klap06-multif0.pdf</a>
Input: x, the spectrum to be whitened
nu, a whittening scaling parameter
Reutrns: gamma(f), the whittening function as a function of frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def whittener(x, freqs, nu=0.33, nb=30):
    &#34;&#34;&#34;Spectral whittening function from Klapuri06: https://www.ee.columbia.edu/~dpwe/papers/Klap06-multif0.pdf
    Input: x, the spectrum to be whitened
           nu, a whittening scaling parameter
    Reutrns: gamma(f), the whittening function as a function of frequency.
    &#34;&#34;&#34;
    Hb, cb = get_Hb(freqs=freqs, nb=nb)
    sigma_bs = np.zeros(len(cb))

    for i in range(len(sigma_bs)):
        sigma_bs[i] = np.sqrt(1 / len(x) * sum(Hb[..., i] * np.abs(x) ** 2))

    yb = sigma_bs ** (nu - 1)

    return interp1d(cb, yb, fill_value=&#34;extrapolate&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="albatros_analysis" href="index.html">albatros_analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="albatros_analysis.harmonic_finder.gaussian" href="#albatros_analysis.harmonic_finder.gaussian">gaussian</a></code></li>
<li><code><a title="albatros_analysis.harmonic_finder.get_Hb" href="#albatros_analysis.harmonic_finder.get_Hb">get_Hb</a></code></li>
<li><code><a title="albatros_analysis.harmonic_finder.get_acctime" href="#albatros_analysis.harmonic_finder.get_acctime">get_acctime</a></code></li>
<li><code><a title="albatros_analysis.harmonic_finder.simple_harm_sweep" href="#albatros_analysis.harmonic_finder.simple_harm_sweep">simple_harm_sweep</a></code></li>
<li><code><a title="albatros_analysis.harmonic_finder.triangle" href="#albatros_analysis.harmonic_finder.triangle">triangle</a></code></li>
<li><code><a title="albatros_analysis.harmonic_finder.whittener" href="#albatros_analysis.harmonic_finder.whittener">whittener</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>